/*
 * ScriptIDE: The coadunation ide for editing scripts in coadunation.
 * Copyright (C) 2009  2015 Burntjam
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * MappingFactory.java
 */

// package path
package com.rift.coad.script.client.files;

// coadunation imports
import com.google.gwt.user.client.rpc.AsyncCallback;
import com.rift.coad.datamapperbroker.client.rdf.DataMapperMethod;
import com.rift.coad.rdf.objmapping.client.base.DataType;
import com.rift.coad.rdf.objmapping.client.resource.ResourceBase;
import com.rift.coad.rdf.objmapping.util.client.type.TypeManager;
import com.rift.coad.script.broker.client.rdf.RDFScriptInfo;
import com.rift.coad.script.client.files.mapping.MappingManagerConnector;
import com.rift.coad.script.client.files.mapping.NoMappingException;
import com.rift.coad.script.client.type.TypeCache;
import com.smartgwt.client.types.Alignment;
import com.smartgwt.client.types.SelectionAppearance;
import com.smartgwt.client.types.SelectionStyle;
import com.smartgwt.client.util.SC;
import com.smartgwt.client.widgets.Canvas;
import com.smartgwt.client.widgets.Label;
import com.smartgwt.client.widgets.Window;
import com.smartgwt.client.widgets.form.DynamicForm;
import com.smartgwt.client.widgets.form.fields.FormItem;
import com.smartgwt.client.widgets.form.fields.SelectItem;
import com.smartgwt.client.widgets.form.fields.CanvasItem;
import com.smartgwt.client.widgets.form.fields.ButtonItem;
import com.smartgwt.client.widgets.form.fields.TextItem;
import com.smartgwt.client.widgets.form.fields.events.ChangedEvent;
import com.smartgwt.client.widgets.form.fields.events.ClickEvent;
import com.smartgwt.client.widgets.form.fields.events.ClickHandler;
import com.smartgwt.client.widgets.form.fields.events.ChangedHandler;
import com.smartgwt.client.widgets.grid.ListGrid;
import com.smartgwt.client.widgets.grid.ListGridField;
import com.smartgwt.client.widgets.grid.ListGridRecord;
import com.smartgwt.client.widgets.layout.VLayout;
import java.util.ArrayList;
import java.util.List;

/**
 * This object is responsible for managing the creation of a mapping display object.
 *
 * @author brett chaldecott
 */
public class MappingFactory {

    /**
     * This object deals with the return types.
     */
    public class ReturnTypeHandler implements ChangedHandler {

        private MappingPanel panel;

        /**
         * The constructor of the return type handler.
         *
         * @param panel The panel that contains all the values to manage.
         */
        private ReturnTypeHandler(MappingPanel panel) {
            this.panel = panel;
        }


        /**
         * Deal with events.
         *
         * @param event The event to handle
         */
        public void onChanged(ChangedEvent event) {
            panel.customReturnType.clearValue();
            panel.customReturnTypeName.clearValue();
            panel.customReturnTypeName.setDisabled(true);
        }
    }


    /**
     * This object handles the events generated by the custom return type handler.
     */
    public class CustomReturnTypeHandler implements ChangedHandler {

        private MappingPanel panel;

        /**
         * The constructor of the return type handler.
         *
         * @param panel The panel that contains all the values to manage.
         */
        private CustomReturnTypeHandler(MappingPanel panel) {
            this.panel = panel;
        }


        /**
         * This method handles the on change event.
         *
         * @param event The event to handle
         */
        public void onChanged(ChangedEvent event) {
            panel.returnType.clearValue();
            panel.customReturnTypeName.setDisabled(false);
        }

    }


    /**
     * This object represents the panel information
     */
    public class MappingPanel extends Canvas implements AsyncCallback {
        protected ListGrid parameterTypeGrid = null;
        protected SelectItem returnType = null;

        // custom values
        protected SelectItem customReturnType;
        protected TextItem customReturnTypeName;
        protected ParameterCanvas customParameters;

        public MappingPanel() {
            try {
                VLayout canvas = new VLayout();
                canvas.setPadding(0);

                DynamicForm form = new DynamicForm();


                // return type
                returnType = new SelectItem();
                returnType.setName("Return");

                returnType.addChangedHandler(new ReturnTypeHandler(this));

                // create a dynamic form to set the return type to a none system type.
                DynamicForm returnForm = new DynamicForm();
                returnForm.setIsGroup(true);
                returnForm.setGroupTitle("Custom Return");

                this.customReturnType = new SelectItem("Type");
                this.customReturnType.setValueMap(TypeManager.getTypesForGroup(TypeManager.NONE_SCOPE_GROUPING[0]));
                this.customReturnType.addChangedHandler(new CustomReturnTypeHandler(this));

                customReturnTypeName = new TextItem("Name:");
                customReturnTypeName.setDisabled(true);

                returnForm.setFields(new FormItem[]{customReturnType,customReturnTypeName});

                CanvasItem returnCanvasItem = new CanvasItem();
                returnCanvasItem.setCanvas(returnForm);
                returnCanvasItem.setName("Custom Return");


                // parameters
                parameterTypeGrid = new ListGrid();
                parameterTypeGrid.setTitleField("Parameter List");
                parameterTypeGrid.setHeight(100);
                parameterTypeGrid.setAlternateRecordStyles(true);
                parameterTypeGrid.setSelectionType(SelectionStyle.SIMPLE);
                parameterTypeGrid.setSelectionAppearance(SelectionAppearance.CHECKBOX);
                parameterTypeGrid.setWidth(410);
                ListGridField actionName = new ListGridField("Name", "name", 410 - 29);
                parameterTypeGrid.setFields(actionName);
                parameterTypeGrid.setAutoFetchData(false);
                parameterTypeGrid.setShowFilterEditor(false);
                CanvasItem canvasItem = new CanvasItem();
                canvasItem.setCanvas(parameterTypeGrid);
                canvasItem.setName("Parameters");

                customParameters = new ParameterCanvas(null);
                CanvasItem customParametersCanvasItem = new CanvasItem();
                customParametersCanvasItem.setCanvas(customParameters);
                customParametersCanvasItem.setName("Custom Parameters");



                // submit buttons
                ButtonItem updateButton = new ButtonItem("Update");
                updateButton.addClickHandler(new ClickHandler() {

                    public void onClick(ClickEvent event) {
                        handleUpdate();
                    }
                });

                form.setFields(new FormItem[]{
                    returnType,returnCanvasItem,canvasItem,
                    customParametersCanvasItem,updateButton});

                canvas.addMember(form);


                // add data
                setInfo();


                // add the canvas values
                this.addChild(canvas);

                // retrieve the mapping information
                MappingManagerConnector.getService().getMapping(scriptInfo.getScope(), scriptInfo.getFileName(), this);
            } catch (Exception ex) {
                SC.say("Failed to setup the mapping information : " + ex.getMessage());
            }
        }



        /**
         * This method sets the grid information
         */
        private void setInfo() {
            try {
                List<ResourceBase> resources = TypeCache.getInstance().getResources();
                ListGridRecord[] records = new ListGridRecord[resources.size()];
                String[] types = new String[resources.size()];
                for (int index = 0; index < resources.size(); ++index) {
                    records[index] = new ListGridRecord();
                    records[index].setAttribute("Name", resources.get(index).getIdForDataType());
                    types[index] = resources.get(index).getIdForDataType();
                }
                parameterTypeGrid.setData(records);
                returnType.setValueMap(types);
            } catch (Exception ex) {
                SC.say("Failed to set the list of types : " + ex.getMessage());
            }
        }


        /**
         *
         * @param caught
         */
        public void onFailure(Throwable caught) {
            if (caught instanceof NoMappingException) {
                return;
            }
            SC.say("Failed to retrieve the mapping information : " + caught.getMessage());
        }


        /**
         * Handle the success calls.
         * @param result
         */
        public void onSuccess(Object result) {
            if (result instanceof DataMapperMethod) {
                setMappingInfo((DataMapperMethod)result);
            }
        }


        /**
         * This method sets up the mapping information.
         *
         * @param mapping The mapping information.
         */
        private void setMappingInfo(DataMapperMethod mapping) {
            try {
                List<ResourceBase> resources = TypeCache.getInstance().getResources();
                if (mapping.getResult() != null) {
                    if (isSystemType(resources, mapping.getResult())) {
                        this.returnType.setValue(mapping.getResult().getIdForDataType());
                        this.customReturnType.clearValue();
                        this.customReturnTypeName.clearValue();
                        this.customReturnTypeName.setDisabled(true);
                    } else {
                        this.returnType.clearValue();
                        this.customReturnType.setValue(mapping.getResult().getBasicType());
                        this.customReturnTypeName.setValue(mapping.getResult().getDataName());
                        this.customReturnTypeName.setDisabled(false);
                    }
                }
                ListGridRecord[] records = parameterTypeGrid.getRecords();
                if ((records == null) || (mapping.getAttributes() == null)) {
                    return;
                }

                List<DataType> customParameterList = new ArrayList<DataType>();
                for (DataType type : mapping.getAttributes()) {
                    if (!isSystemType(resources, type)) {
                        customParameterList.add(type);
                    } else {
                        for (ListGridRecord record : records) {
                            String name = record.getAttributeAsString("Name");
                            if (name.equals(type.getIdForDataType())) {
                                parameterTypeGrid.selectRecord(record);
                            }
                        }
                    }
                }

                this.customParameters.setParameters(customParameterList);
            } catch (Exception ex) {
                SC.say("Failed to set up the mapping : " + ex.getMessage());
            }
        }

        
        /**
         * This method is called to handle the update call.
         */
        private void handleUpdate() {
            try {
                // setup the basic mapping.
                DataMapperMethod mapping = DataMapperMethod.createInstance();
                mapping.setName(scriptInfo.getFileName());
                
                // process the return type
                List<ResourceBase> resources = TypeCache.getInstance().getResources();
                if (returnType.getValue() != null) {
                    String value = returnType.getValue().toString();
                    for (ResourceBase resource : resources) {
                        if (value.equals(resource.getIdForDataType())) {
                            mapping.setResult(resource);
                            break;
                        }
                    }
                } else if (this.customReturnType.getValue() != null) {
                    String type = this.customReturnType.getValue().toString();
                    if (this.customReturnTypeName.getValue() == null) {
                        SC.say("The variable name must be supplied");
                        return;
                    }
                    String name = this.customReturnTypeName.getValue().toString();
                    DataType returnType = TypeManager.getType(type);
                    returnType.setDataName(name);
                    mapping.setResult(returnType);
                }

                // handle the system types
                ListGridRecord[] records = parameterTypeGrid.getSelection();
                for (ListGridRecord record : records) {
                    String name = record.getAttributeAsString("Name");
                    for (ResourceBase resource : resources) {
                        if (name.equals(resource.getIdForDataType())) {
                            mapping.addAttribute(resource);
                        }
                    }
                }

                // handle the custom types
                DataType[] customParameters = this.customParameters.getParameters();
                for (DataType parameter : customParameters) {
                    mapping.addAttribute(parameter);
                }

                // retrieve the mapping information
                MappingManagerConnector.getService().updateMapping(
                        scriptInfo.getScope(), scriptInfo.getFileName(), mapping, this);
            } catch (Exception ex) {
                SC.say("Failed to retrieve the resource information : " + ex.getMessage());
            }
        }

        /**
         * This method returns true if the data type being searched for is a system type
         * @param resources
         * @param type
         * @return
         */
        private boolean isSystemType(List<ResourceBase> resources, DataType type) {
            if (resources == null) {
                return false;
            }
            for (ResourceBase resource : resources) {
                if (resource.getIdForDataType().equals(type.getIdForDataType())) {
                    return true;
                }
            }
            return false;
        }

    }

    // private member variables
    private RDFScriptInfo scriptInfo;
    private FileEditorFactory factory;
    private Window win = null;


    /**
     * This constructor sets up the global variables.
     *
     * @param scriptInfo The script information to retrieve the display information for.
     * @param factory The factory information
     */
    public MappingFactory(RDFScriptInfo scriptInfo, FileEditorFactory factory) {
        this.scriptInfo = scriptInfo;
        this.factory = factory;
    }


    /**
     * This method is called to create the window that the mapping information will be
     * presented in.
     */
    public void createWindow() {
        if (win == null) {
            win = new Window();
            win.setTitle("Mapping");
            win.setKeepInParentRect(true);
            win.setWidth(520);
            win.setHeight(460);
            int windowTop = 40;
            int windowLeft = factory.getPanel().getWidth()- (win.getWidth() + 20);
            win.setLeft(windowLeft);
            win.setTop(windowTop);
            win.setCanDragReposition(true);
            win.setCanDragResize(true);
            win.setMembersMargin(5);

            win.addItem(new MappingPanel());

            factory.getPanel().addChild(win);
        }
        win.draw();
    }
    
}
